`executeStartProgressAnimation()` only triggers once thanks to the `BasePackageNotificationController.startedProgressAnimation` variable

This variable gets set to `false` in the `BasePackageNotificationController.reset()` method. It also is set via the `setStartedProgressAnimation()` method.

`GlyphNotificationManager` manages state of the currently active controller via `mActivieController`. `reset()` is called inside `GlyphNotificationManager.finishOrStartAnotherGlyph()`. This is called in `finishCurrentGlyph()`

There are a few places in `GlyphNotificationManager` where `finishCurrentGlyph()` gets called
- `finishActivieContrllerIsIfNeeded()` 
- `updateGlyphResult()`, based on the `BasePackageNotificationController.getTargetStop()` value
- `cancelAction()`

### `BasePackageNotificationController.getTargetStop()`

`targetStop` seems to be set as soon as `int onNotificationPosted` that's returned by `findTargetParser.onNotificationPosted()` in `BaseNotificationController` returns a -1. 

`UberPickupTimeParserRule` never returns a -1. Only returns a 0 or 1. This is why the controller does not get reset.

`UberCancelParserRule` returns a -1 under some cases. I can use this to turn off the LEDs I guess.


## Cancelling an animation

### Attempting to spoof notifs that match `UberCancelParserRule`

- Notification `title` can't be null. 
- Title should be `Cancel Trip`. 

This works perfectly. I believe it can be used to reset any animation. I just had to remember to add the string from Uber's `strings.xml` which contains the `Cancel Trip` text to my own app's `strings.xml`


## Hiding notifications from user

### Attempting to cancel notification immediately sending it
This does not trigger any LED animation update.

### Attempting to cancel notification with a small delay
Very hacky approach, but this sort of works. With a delay like 100ms, the notification does not seem to be detected by the `GlyphNotificationListenerService`. Howevever 1000ms works, but the notification icon pops up in the status bar momentarily. 

200ms seems like a magic number where the notification doesn't pop up in the status bar but still gets recognized by `GlyphNotificationListenerService`.


## Making the progress bar go back down in `UberPickupTimeParserRule`

The rule uses both `setProgress()` and `setActualProgress()` methods on the `GlyphResult` object. It calculates the progress using the `calculateProcess()` and `calculateActualProcess()` methods respectively, which each take in the originally set `readMinute` variable. This variable is set autoamtically during the first notification sent to `GlyphNotificationListenerService` after a reset.

```java
// Returns a percentage, cannot be negative. 
public final int calculateProcess(int i) {
    if (i > this.maxProcessMinute) {
        return 0;
    }
    return ((this.maxProcessMinute - i) * 100) / this.maxProcessMinute;
}

// Returns a raw percentage, can be negative as well.
public final int calculateActualProcess(int i) {
    return ((this.maxProcessMinute - i) * 100) / this.maxProcessMinute;
}
```

### How does `maxProcessMinute` in `BaseNotificationParserRule` (in our case, `UberPickupTimeParserRule`) get set?
- By default it's -1.

Seems to be set inside `BaseNotificationParser`. So for us this would be the `UberParser.setMaxProcessMinute()` method, which in turn sets the `maxProcessMinute` variables for each of the rules in the parser.

`UberParser.setMaxProcessMinute()` is called for the first time in `UberController.onNotificationPosted()`. It only triggers once and is set to be the initial `readMinute` value.

### How is `readMinute` set?

It's set differently based on the parser rule being used. For `UberPickupTimeParserRule`, it just uses a regex to find the first instance of a number in the notification title. If this fails, it returns -1. Setting of `maxProcessMinute` only works if the initial `readMinute` is > 0 however.

### Where do the `actualProgress` and `progress` variables in `GlyphResult` get read?

After the notification is correctly parsed, the `GlyphNotificationManager` calls `updateGlyphResult()`. This gets the current `GlyphResult` from `UberController`. 

If `getProgress()` returns -1 (which should never/rarely be the case once `UberController` is initialized), the `GlyphHelper` immediately triggers `displayGlyphResult()`

In most cases however, it seems that the system continued with the `timerUpdateProgress()` method. Uh oh, I think this implies that the only thing controllable via this approach is the timer.

### How does `timerUpdateProgress()` work?

If the progress is < 100, it calls `GlyphHelper.displayGlyphResult()`. This should imply that it will update with whatever the
returned progress value is, and we should be able to reduce this via our notifications as well. 

```java
// glyphResult is the new GlyphResult object generated by the current parser.
// getOneMinuteProgress() seems to return what the expected progress per minute is
// currentGlyphResult is the previous/current GlyphResult object

// Lets assume current progress is 20
// One minute progress is 10
// New progress is 40

// 1) 20 + 10 < 40 = true
// 2) 20 + 10 < 30 = false
// 3) 20 + 10 < 20 = false
// 4) 20 + 10 < 9 = false
if (this.currentGlyphResult.getProgress() + matchParser.getOneMinuteProgress() < glyphResult.getProgress()) {
    // Get delta in new and old progress
    int progress = glyphResult.getProgress() - this.currentGlyphResult.getProgress();
    this.speedUpFrame = progress;
    this.speedUpFrame = (int) (((float) progress) * matchParser.getSpeedUpFrameRate());
    this.ignoreUpdateProgress = 0;

// 1) skip
// 2) 20 - 10 > 30 = false
// 3) 20 - 10 > 20 = false
// 4) 20 - 10 > 9 = true. Seems like in this case any progress update is ignored if its negative...
} else if (this.currentGlyphResult.getProgress() - matchParser.getOneMinuteProgress() > glyphResult.getActualProgress()) {
    this.speedUpFrame = 0;
    this.ignoreUpdateProgress = this.currentGlyphResult.getProgress() - glyphResult.getActualProgress();

// 1) skip
// 2) Do nothing if the delta progress is equal to one minute progress
// 3) Do nothing if the progress remains the same
// 4) Skip
} else {
    this.ignoreUpdateProgress = 0;
    this.speedUpFrame = 0;
}
```





To try decompiling:
- `com.nothing.thirdparty`
- Nothing camera app